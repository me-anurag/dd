{
  "intro": {
      "basic": [
          "Greetings, Iâ€™m Detective Algo, your deadlock-busting sleuth! ğŸ•µï¸â€â™‚ï¸ Got {num_processes} workers ({processes}) and {num_resources} tools ({resources}). The scene: {allocations}; {requests}. My mission? Sniff out cycles in the resource graph that spell deadlock trouble. Letâ€™s crack this case! ğŸ”",
          "Hey there, itâ€™s Algo, your friendly deadlock detective! ğŸ•µï¸â€â™‚ï¸ Weâ€™re in a factory with {num_processes} workers ({processes}) and {num_resources} tools ({resources}). Snapshot: {allocations}; {requests}. Iâ€™m using DFS to hunt for pesky cycles. Ready to solve this mystery? ğŸš¨"
      ],
      "verbose": [
          "Well, well, well! Detective Algo at your service, ready to unravel a deadlock mystery! ğŸ•µï¸â€â™‚ï¸ Iâ€™ve just received a case file: {num_processes} workers ({processes}) and {num_resources} tools ({resources}). The crime scene shows {allocations}, and the suspectsâ€™ demands are {requests}. My trusty DFS algorithm will comb through the resource graph to find any cyclesâ€”those sneaky loops where workers wait forever. Buckle up, this is gonna be a wild ride! ğŸ” *Tip: A cycle in the resource graph means a deadlock, where no one gets what they need!*",
          "Hello, folks! Itâ€™s your pal, Detective Algo, diving into a juicy deadlock case! ğŸ•µï¸â€â™‚ï¸ The setup: {num_processes} workers ({processes}) juggling {num_resources} tools ({resources}). Current status? {allocations}; {requests}. Iâ€™m about to build a resource allocation graph and use DFS to sniff out cyclesâ€”those circular wait patterns that grind everything to a halt. Letâ€™s get to work! ğŸš¨ *Did you know? DFS stands for Depth-First Search, a method to explore graphs by diving deep into each path!*"
      ]
  },
  "start": {
      "basic": [
          "Starting my investigation at {node}â€™s desk! ğŸ–¥ï¸ DFS kickoff: Iâ€™m tracing {node}â€™s connections to spot any cycle shenanigans.",
          "On the case at {node}â€™s workstation! ğŸ“‹ DFS begins: {node} is my starting point for this deadlock hunt."
      ],
      "verbose": [
          "Alright, letâ€™s kick this off at {node}â€™s desk! ğŸ–¥ï¸ Iâ€™m starting my DFS investigation here because itâ€™s a process node, and processes are where the action begins. Why {node}? Itâ€™s unvisited, and I need to explore every nook and cranny of this graph. My plan: follow {node}â€™s resource requests and allocations to see if they lead to a cycle. Here we go! ğŸš€ *Tip: Starting with a process node helps us trace resource dependencies systematically!*",
          "Time to get my detective hat on at {node}â€™s workstation! ğŸ“‹ Iâ€™m launching DFS from {node} since itâ€™s a fresh process node. My goal? Trace every edgeâ€”requests for resources or allocationsâ€”to uncover any loops. If {node} is waiting for something thatâ€™s already tied up, we might be onto a deadlock. Letâ€™s dive in! âš¡ *Did you know? DFS uses a stack to keep track of where weâ€™ve been, like breadcrumbs in a maze!*"
      ]
  },
  "visit": {
      "basic": [
          "Snooping around {node}â€™s desk! Itâ€™s {context}. ğŸ” DFS step: Iâ€™m adding {node} to my stack to track my path.",
          "At {node}â€™s station, where itâ€™s {context}. ğŸ–¥ï¸ DFS note: {node} is now on my stack, marking it â€˜in progressâ€™."
      ],
      "verbose": [
          "Letâ€™s take a closer look at {node}â€™s desk! ğŸ” Itâ€™s {context}. Iâ€™m adding {node} to my DFS stack, which is like pinning a note to my detective board to remember where I am. Why? This helps me track my path and spot if I loop back to {node} laterâ€”a sure sign of a cycle! Iâ€™m also marking {node} as visited to avoid redundant checks. *Tip: The stack in DFS is crucial for detecting cycles by showing which nodes are still being explored!*",
          "Peeking at {node}â€™s workstation, where itâ€™s {context}. ğŸ–¥ï¸ In DFS terms, Iâ€™m pushing {node} onto my stack, signaling itâ€™s under investigation. This stack is my memoryâ€”it tells me the path Iâ€™ve taken. If I see {node} again while itâ€™s still on the stack, bam! Thatâ€™s a cycle, and weâ€™ve got a deadlock suspect. *Did you know? Visiting a node means weâ€™re actively exploring its connections, like following clues in a case!*"
      ]
  },
  "check_edge": {
      "basic": [
          "{node} is {edge_type} {neighbor}. Letâ€™s follow this clue! ğŸ”— DFS check: This edge might lead to a cycle.",
          "From {node} to {neighbor} via a {edge_type} link. ğŸ§ DFS step: Checking if this connection causes trouble."
      ],
      "verbose": [
          "Hot on the trail! {node} is {edge_type} {neighbor}. ğŸ”— This edge is a clue in my DFS search. If {node} is a process, itâ€™s requesting {neighbor} (a resource); if itâ€™s a resource, itâ€™s allocated to {neighbor} (a process). Iâ€™m checking this edge because it shows a dependencyâ€”{node} needs {neighbor} to proceed. If this leads to a node already on my stack, we might have a cycle! *Tip: Edges in the resource graph show whoâ€™s waiting for what, the key to finding deadlocks!*",
          "Ooh, interesting! From {node}, Iâ€™ve got a {edge_type} link to {neighbor}. ğŸ§ In DFS, this edge is criticalâ€”itâ€™s a dependency I need to investigate. For example, if {node} is a process begging for {neighbor} (a resource), I need to see whoâ€™s holding {neighbor}. My reasoning? This connection could lead me back to a node Iâ€™m already exploring, signaling a cycle. Letâ€™s follow it! *Did you know? Resource graphs have two types of edges: request (process to resource) and allocation (resource to process)!*"
      ]
  },
  "dive": {
      "basic": [
          "{neighbor} is uncharted territory! Letâ€™s explore! ğŸŒŸ DFS action: Adding {neighbor} to the stack and diving in.",
          "{neighbor} hasnâ€™t been checked yet. Off we go! ğŸšª DFS step: {neighbor} is next on my stack."
      ],
      "verbose": [
          "New lead! {neighbor} is a fresh node I havenâ€™t visited yet. ğŸŒŸ Iâ€™m diving into it by adding {neighbor} to my DFS stack and setting its parent as {node}. Why? This parent link helps me trace back the path if I find a cycle. Iâ€™m exploring {neighbor} because itâ€™s part of {node}â€™s dependencies, and I need to ensure it doesnâ€™t loop back to an active node. Hereâ€™s hoping for clues! ğŸš€ *Tip: Diving into unvisited nodes expands our search, like chasing new leads in a case!*",
          "Uncharted territory at {neighbor}! ğŸšª Since I havenâ€™t seen this node before, Iâ€™m pushing it onto my stack and noting that {node} led me here. This is a DFS diveâ€”my goal is to explore all of {neighbor}â€™s connections. Why bother? If {neighbor} connects to a node already on my stack, weâ€™ve got a cycle, and thatâ€™s a deadlock red flag. Letâ€™s investigate! âš¡ *Did you know? The parent dictionary in DFS helps reconstruct the cycle path when we find one!*"
      ]
  },
  "cycle_found": {
      "basic": [
          "Bingo! {neighbor} forms a cycle: {cycle}! ğŸš¨ DFS find: This loop means a deadlockâ€”workers are stuck!",
          "Gotcha! {neighbor} creates a cycle: {cycle}. ğŸ›‘ DFS lesson: This cycle is a deadlock trap!"
      ],
      "verbose": [
          "Case closed! ğŸš¨ Iâ€™ve hit a cycle at {neighbor}: {cycle}! This is a deadlock, folksâ€”{node} leads to {neighbor}, which loops back through {cycle}. How did I find it? {neighbor} was already on my stack, meaning weâ€™ve circled back. This loop shows workers waiting in a chain, like a standoff where no one budges. Time to report this deadlock! ğŸ“¢ *Tip: A cycle in the resource graph means processes canâ€™t proceed because theyâ€™re all waiting for each other!*",
          "Jackpot! ğŸ›‘ {neighbor} reveals a cycle: {cycle}! I detected this because {neighbor} is already on my DFS stack, indicating a loop from {node} back to {neighbor}. Letâ€™s break it down: each node in {cycle} is waiting for the next, creating a deadlock where no one can move. My parent dictionary helped me trace this path. Weâ€™ve got a crime scene! ğŸ˜± *Did you know? Detecting a cycle confirms a deadlock, as it shows a circular dependency in the system!*"
      ]
  },
  "backtrack": {
      "basic": [
          "{node}â€™s a dead end. Backtracking! ğŸ”™ DFS step: Popping {node} off the stack.",
          "No luck at {node}. Retreating! âª DFS note: {node} is done, off the stack it goes."
      ],
      "verbose": [
          "Dead end at {node}! ğŸ”™ Iâ€™ve checked all its connections, and thereâ€™s no cycle here. Time to backtrack by popping {node} off my DFS stack. Why? Iâ€™m done exploring {node}â€™s dependencies, so I retreat to its parent to continue the search. This keeps my investigation tidy and ensures I donâ€™t miss any paths. Onward! âª *Tip: Backtracking in DFS means weâ€™ve exhausted a nodeâ€™s possibilities and need to revisit earlier nodes!*",
          "No cycles at {node}. Time to pull back! âª Iâ€™m removing {node} from my stack since Iâ€™ve explored all its edges. My reasoning: {node} didnâ€™t lead to a cycle, so I backtrack to its parent to check other paths. This is classic DFSâ€”dive deep, then retreat when you hit a wall. Letâ€™s keep hunting! âš¡ *Did you know? Backtracking ensures we systematically explore every possible path in the graph!*"
      ]
  },
  "no_cycle": {
      "basic": [
          "Case solved! No cycles foundâ€”factoryâ€™s all clear! ğŸ† DFS result: No deadlocks, smooth sailing!",
          "Mission complete! No deadlock cycles. ğŸ‰ DFS wrap-up: Everyoneâ€™s working happily!"
      ],
      "verbose": [
          "Victory! ğŸ† Iâ€™ve scoured the entire graph, and thereâ€™s not a single cycle in sight. That means no deadlocksâ€”every worker can get their tools eventually. How do I know? My DFS explored every process and resource, checking all edges for loops, and came up empty. The factoryâ€™s running like a well-oiled machine! ğŸ‰ *Tip: A cycle-free graph means the system is in a safe state, with no circular waits!*",
          "Success! ğŸ‰ After a thorough DFS investigation, I can confirm: no cycles, no deadlocks! I visited every node, followed every edge, and found no loops where workers are stuck waiting. My stack is empty, and all paths are clear. This system is safe, and everyoneâ€™s getting their resources. Case closed! ğŸ† *Did you know? A safe state ensures all processes can complete without getting stuck!*"
      ]
  },
  "cycle_detected": {
      "basic": [
          "Deadlock alert! Found a cycle: {cycle}. ğŸ˜± DFS find: Workers are trapped in a loop!",
          "Trouble! Deadlock at {cycle}. ğŸš¨ DFS result: This cycle means a resource jam!"
      ],
      "verbose": [
          "Red alert! ğŸ˜± Iâ€™ve uncovered a deadlock with this cycle: {cycle}. My DFS search confirmed that these nodes form a loop where each is waiting for the nextâ€”like a never-ending stakeout. Whyâ€™s this bad? No one can proceed, halting the factory. I traced this using my stack and parent links to pinpoint the exact path. Time to break this deadlock! ğŸš¨ *Tip: Deadlocks require intervention, like freeing a resource or halting a process!*",
          "Emergency! ğŸš¨ A deadlockâ€™s been confirmed at {cycle}. My DFS investigation revealed a cycle where {cycle} nodes are locked in a circular wait. I found this by spotting a node already on my stack, then reconstructing the loop with my parent dictionary. This means the systemâ€™s stuckâ€”nobodyâ€™s moving until we resolve this jam. Letâ€™s get to fixing it! ğŸ“› *Did you know? Deadlock recovery might involve terminating a process or preempting resources!*"
      ]
  }
}